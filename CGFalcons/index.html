<!DOCTYPE HTML>
<html lang="en">

<link rel="icon" href="../images/favreaucon.png" type="image/png">

<head>
<script src="http://ajax.googleapis.com/ajax/libs/jquery/1.11.0/jquery.min.js"></script>
<link rel="stylesheet" type="text/css" href="sturl.css">
<!--For Ubuntu Font All the time!-->
<link rel="stylesheet" type="text/css" href="http://fonts.googleapis.com/css?family=Ubuntu:regular,bold&subset=Latin">
<title>Computer Graphics: The Falcons</title>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
<meta property="og:image" content="https://raw.githubusercontent.com/sia/sia.github.io/master/CGFalcons/falconslogosmall.png" />
</head>

<body>

<div  id="main"  class="main">
  </br>
  </br>
  <center>

  <h2>Computer Graphics</h2>
  <img src="falconslogosmall.png">
  <h2>TEAM: The Falcons</h2>
<p><b>Members: </b>Neil, Ben, Jordan, Shahan</p>

  <p>Web page for Rutgers Computer Graphics 2015 Group 3 Blog!</P>

    <a href = "http://sia.github.io/RUCGB1/" 
      title = ""
      style="font-size: 15pt;
      color:magenta;">
      LINK TO PLAYABLE WEBGL GAME</a></br>

<p>Here is a little informational video/demo of the game.</p>

<iframe width="300" height="200"
src="http://www.youtube.com/embed/DvqJYxep6fA">
</iframe>


<p>
<b>10/10/15</b>
<ul>
<li>Created branch of repo.</li>
<li>Looked up the tutorials inside assignment PDF.</li>
<li>Became familiar with terms and group discussed navigation.</li>
<li>Talked about games like "Starcraft" and "DOTA" and other 
games that involve mouse click movement similar to what is 
described in the PDF.</li>
<li>Googled other things about Unity navigation and youtube videos 
about Unity and navigation.</li>
</ul>

<b>10/15/15</b>
<ul>
<li>Small meetup.</li>
<li>Group divided up work amongst selves.</li>
<li>We talked about blog website and setup essentially the </li>
<li>same as this PDF with pictures and video links.</li>
<li>Will periodically update GitHub IO site: 
http://sia.github.io/CGB1/ for our blog.</li>
</ul>
</br>
How it works:
</br>
Level1 and Level3 are just point and click basic.</br>
Level2 is WASD and space to jump.</br>
Ran into issues with animated prefabs going down slopes 
they seem to be stuck in a falling animation.
</br>
We made a simple OnMouseDown set of UI texts for level selection 
in the main menu. You can get to any scene/level from the 0th scene.
</br>
We also have a simple Waypoint moving sphere in Level1 and Level3 
that constantly carves the navmesh surface.
</br></br></br>
For <b>optimal maximum fun</b> clone our repo!
</br></br>
<a href = "https://github.com/CG-F15-3-Rutgers/UnityProjects" 
      title = ""
      style="font-size: 15pt;
      color:magenta;">
      B1 Unity Project GitHub Repository</a></br>
<b>Make sure you have Blender installed to correctly open and unpack the project </br>
Some of the models are made in Blender and will not import if you do not have Blender installed</b>

<h1>A2 Assignment Screen Shots</h1></br>
<b>10/26/15</b></br>
<img src="partAPoly1.png"></br>
<img src="partBPoly2.png"></br>
<img src="partPolyfix.png"></br>
<p>The issue with polygons2 was the shapes were concave</br>
and they intersected upon themselves.</br>
A simple fix for this was to just make them convex and</br>
unfolded so GJK and EPA (unmodified) could be used on them.</p> 
</p>
<h1>A3 Assignment Blog</h1>
<b>11/4/15</b></br>
<p>
The goal force is pretty straight forward. We were given the direction and dt.  </br>
We just set the goal force to (direction * speed) – velocity / dt. The proximity force  </br>
was harder. It included using a spatial database to locate all of the nearby neighbors.  </br>
We determined if the neighbor was an agent and applied the proximity force based on the  </br>
formula for agents. If it was a wall, we applied the force based on the formula for walls  </br>
which is a very similar formula. We returned the force of all of these neighbors acting together. </br> 
The agent repulsion force and wall repulsion force were both found the same way. Search through the  </br>
neighbors in the spatial database. The agent function looked for agents and calculated a  </br>
force based on position, radius, and body force. The wall function looked for walls and  </br>
calculated a force based on the wall normal, points, and distance from the wall.  </br>

Altogether our algorithm gave us slightly high steerbench scores. We noticed that our agents weren’t  </br>
being repelled enough which resulted in many collisions but very quick finish times. Upon talking to  </br>
Mahyar, we realized that by increasing the proximity force by a factor of 3 we could greatly reduce  </br>
collisions with very small damage to our finish time. This allowed us to achieve steerbench scores  </br>
that were very similar to the ones listed in the assignment 3 write up.  </br></br>

<a href="https://www.youtube.com/watch?v=x4jV404zp1k" target="_blank">Bottleneck Video</a></br></br>
<a href="https://www.youtube.com/watch?v=YK7lvLLrptE" target="_blank">Hallway One Way Video</a></br></br>
<a href="https://www.youtube.com/watch?v=mdTS1wzLyBE" target="_blank">Hallway Two Way Video</a></br></br>
<a href="https://www.youtube.com/watch?v=ePBboM6zpC8" target="_blank">Hallway Four Way Video ( ͡° ͜ʖ ͡°)</a></br></br>

</p>

    </br>
    <a href = "http://sia.github.io"
      title = "Author of this site" 
      style="font-size: 8pt"
      >
      sia.github.io</a>
  </center>

</div><!--End of the html, links, non threejs, essentially the website, in a div zindex > than threejs-->

<script src="../js/Three.js"></script>
<script src="../js/Detector.js"></script>
<script src="../js/Stats.js"></script>
<script src="../js/OrbitControls.js"></script>
<script src="../js/THREEx.KeyboardState.js"></script>
<script src="../js/THREEx.FullScreen.js"></script>
<script src="../js/THREEx.WindowResize.js"></script>
<!--Imported three.js lib files, may need to update-->
<div id="ThreeJS" class="ThreeJS"></div>
<script>
//global variables
var container, scene, camera, renderer, controls, stats;
var keyboard = new THREEx.KeyboardState();
var clock = new THREE.Clock();

var light2, light, loader;
var lensflare;
var specv = '#00FF00';
var emv = '#1A0000';

var cube;
var cube2;
var cube3;
var cube4;
var cube5;
var cube6;

init();
animate();
function init() 
{
  scene = new THREE.Scene();

  var SCREEN_WIDTH = window.innerWidth, SCREEN_HEIGHT = window.innerHeight;	
  var VIEW_ANGLE = 45, ASPECT = SCREEN_WIDTH / SCREEN_HEIGHT, NEAR = 0.1, FAR = 20000;
  camera = new THREE.PerspectiveCamera( VIEW_ANGLE, ASPECT, NEAR, FAR);
  scene.add(camera);
  camera.position.set(-19,5,9);
  camera.lookAt(scene.position);	

  //Renderer create and start the renderer; choose antialias setting.
  if ( Detector.webgl )
    renderer = new THREE.WebGLRenderer( {antialias:true, alpha: true } );
  else
    renderer = new THREE.CanvasRenderer(); 

  //renderer.setClearColor( scene.fog.color, 1 );


  renderer.setSize(SCREEN_WIDTH, SCREEN_HEIGHT);

  // fog must be added to scene before first render
  //scene.fog = new THREE.FogExp2( 0x9999ff, 100000000);

  // attach div element to variable to contain the renderer
  container = document.getElementById( 'ThreeJS' );
  container.appendChild( renderer.domElement );

  //

  renderer.gammaInput = true;
  renderer.gammaOutput = true;

  //events
  // automatically resize renderer
  THREEx.WindowResize(renderer, camera);

  controls = new THREE.OrbitControls( camera, renderer.domElement );
  //controls.maxPolarAngle = Math.PI/2;

  //Light
  light = new THREE.PointLight(0xffffff, 1, 3000);
  light.position.set(0,200,200);
  scene.add(light);


  cube = new  THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube2 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube3 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube4 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube5 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube6 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube7 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );
  cube8 = new THREE.Mesh( new THREE.CubeGeometry( 2, 20, 2 ), new THREE.MeshNormalMaterial() );

  scene.add(cube);

  cube2.position.x = 10;
  scene.add(cube2);

  cube3.position.x = 20;
  scene.add(cube3);

  cube4.position.x = 30;
  scene.add(cube4);

  cube5.position.x = 40;
  scene.add(cube5);

  cube6.position.x = 50;
  scene.add(cube6);

  cube7.position.x = 60;
  scene.add(cube7);

  cube8.position.x = 70;
  scene.add(cube8);

  }//END INIT

function onWindowResize( event ) {

  renderer.setSize( window.innerWidth, window.innerHeight );

  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();

}


function animate() 
{
  requestAnimationFrame( animate );
  render();		
  update();

  cube.rotation.y += 0.04;
  cube2.rotation.y += 0.04;
  cube3.rotation.y += 0.04;
  cube4.rotation.y += 0.04;
  cube5.rotation.y += 0.04;
  cube6.rotation.y += 0.04;
  cube7.rotation.y += 0.04;
  cube8.rotation.y += 0.04;


  cube.rotation.x += 0.01;
  cube2.rotation.x += 0.02;
  cube3.rotation.x += 0.03;
  cube4.rotation.x += 0.04;
  cube5.rotation.x += 0.05;
  cube6.rotation.x += 0.06;
  cube7.rotation.x += 0.07;
  cube8.rotation.x += 0.08;


}//END ANIM

function update()
{
  // delta = change in time since last call (in seconds)
  //var delta = clock.getDelta(); 

  controls.update();
}

function render() 
{	
  var time = Date.now() * 0.0005;
  var delta = clock.getDelta();


  renderer.render( scene, camera );
}

</script>

</body>

</html>
